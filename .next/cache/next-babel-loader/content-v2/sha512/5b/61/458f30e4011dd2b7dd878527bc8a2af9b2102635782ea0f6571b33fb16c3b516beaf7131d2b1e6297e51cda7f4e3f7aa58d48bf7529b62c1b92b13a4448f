{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React, { useState, useEffect, useCallback, useRef } from 'react';\nexport var useStateWithPromise = function useStateWithPromise(initialState) {\n  _s();\n\n  var _useState = useState(initialState),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var resolverRef = useRef(null);\n  useEffect(function () {\n    if (resolverRef.current) {\n      resolverRef.current(state);\n      resolverRef.current = null;\n    }\n    /**\r\n     * Since a state update could be triggered with the exact same state again,\r\n     * it's not enough to specify state as the only dependency of this useEffect.\r\n     * That's why resolverRef.current is also a dependency, because it will guarantee,\r\n     * that handleSetState was called in previous render\r\n     */\n\n  }, [resolverRef.current, state]);\n  var handleSetState = useCallback(function (stateAction) {\n    setState(stateAction);\n    return new Promise(function (resolve) {\n      resolverRef.current = resolve;\n    });\n  }, [setState]);\n  return [state, handleSetState];\n};\n\n_s(useStateWithPromise, \"EUMSdK+jLdICJIaWW9bEXx6tPAg=\");","map":{"version":3,"sources":["C:/off-saas/utils/useStateWithPromise.js"],"names":["React","useState","useEffect","useCallback","useRef","useStateWithPromise","initialState","state","setState","resolverRef","current","handleSetState","stateAction","Promise","resolve"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,EAAqCC,WAArC,EAAkDC,MAAlD,QAAgE,OAAhE;AAEA,OAAO,IAAMC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACC,YAAD,EAAkB;AAAA;;AAAA,kBACvBL,QAAQ,CAACK,YAAD,CADe;AAAA,MAC1CC,KAD0C;AAAA,MACnCC,QADmC;;AAEjD,MAAMC,WAAW,GAAGL,MAAM,CAAC,IAAD,CAA1B;AAEAF,EAAAA,SAAS,CAAC,YAAM;AACd,QAAIO,WAAW,CAACC,OAAhB,EAAyB;AACvBD,MAAAA,WAAW,CAACC,OAAZ,CAAoBH,KAApB;AACAE,MAAAA,WAAW,CAACC,OAAZ,GAAsB,IAAtB;AACD;AACD;AACN;AACA;AACA;AACA;AACA;;AACK,GAXQ,EAWN,CAACD,WAAW,CAACC,OAAb,EAAsBH,KAAtB,CAXM,CAAT;AAaA,MAAMI,cAAc,GAAGR,WAAW,CAAC,UAACS,WAAD,EAAiB;AAClDJ,IAAAA,QAAQ,CAACI,WAAD,CAAR;AACA,WAAO,IAAIC,OAAJ,CAAY,UAAAC,OAAO,EAAI;AAC5BL,MAAAA,WAAW,CAACC,OAAZ,GAAsBI,OAAtB;AACD,KAFM,CAAP;AAGD,GALiC,EAK/B,CAACN,QAAD,CAL+B,CAAlC;AAOA,SAAO,CAACD,KAAD,EAAQI,cAAR,CAAP;AACD,CAzBI;;GAAMN,mB","sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from 'react';\r\n\r\nexport const useStateWithPromise = (initialState) => {\r\n    const [state, setState] = useState(initialState);\r\n    const resolverRef = useRef(null);\r\n  \r\n    useEffect(() => {\r\n      if (resolverRef.current) {\r\n        resolverRef.current(state);\r\n        resolverRef.current = null;\r\n      }\r\n      /**\r\n       * Since a state update could be triggered with the exact same state again,\r\n       * it's not enough to specify state as the only dependency of this useEffect.\r\n       * That's why resolverRef.current is also a dependency, because it will guarantee,\r\n       * that handleSetState was called in previous render\r\n       */\r\n    }, [resolverRef.current, state]);\r\n  \r\n    const handleSetState = useCallback((stateAction) => {\r\n      setState(stateAction);\r\n      return new Promise(resolve => {\r\n        resolverRef.current = resolve;\r\n      });\r\n    }, [setState])\r\n  \r\n    return [state, handleSetState];\r\n  };"]},"metadata":{},"sourceType":"module"}