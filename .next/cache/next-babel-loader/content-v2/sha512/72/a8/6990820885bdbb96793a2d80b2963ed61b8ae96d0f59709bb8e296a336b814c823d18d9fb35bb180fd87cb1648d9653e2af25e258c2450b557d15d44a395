{"ast":null,"code":"import React, { useState, useEffect, useCallback, useRef } from 'react';\nexport const useStateWithPromise = initialState => {\n  const {\n    0: state,\n    1: setState\n  } = useState(initialState);\n  const resolverRef = useRef(null);\n  useEffect(() => {\n    if (resolverRef.current) {\n      resolverRef.current(state);\n      resolverRef.current = null;\n    }\n    /**\r\n     * Since a state update could be triggered with the exact same state again,\r\n     * it's not enough to specify state as the only dependency of this useEffect.\r\n     * That's why resolverRef.current is also a dependency, because it will guarantee,\r\n     * that handleSetState was called in previous render\r\n     */\n\n  }, [resolverRef.current, state]);\n  const handleSetState = useCallback(stateAction => {\n    setState(stateAction);\n    return new Promise(resolve => {\n      resolverRef.current = resolve;\n    });\n  }, [setState]);\n  return [state, handleSetState];\n};","map":{"version":3,"sources":["C:/off-saas/utils/useStateWithPromise.js"],"names":["React","useState","useEffect","useCallback","useRef","useStateWithPromise","initialState","state","setState","resolverRef","current","handleSetState","stateAction","Promise","resolve"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,EAAqCC,WAArC,EAAkDC,MAAlD,QAAgE,OAAhE;AAEA,OAAO,MAAMC,mBAAmB,GAAIC,YAAD,IAAkB;AACjD,QAAM;AAAA,OAACC,KAAD;AAAA,OAAQC;AAAR,MAAoBP,QAAQ,CAACK,YAAD,CAAlC;AACA,QAAMG,WAAW,GAAGL,MAAM,CAAC,IAAD,CAA1B;AAEAF,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIO,WAAW,CAACC,OAAhB,EAAyB;AACvBD,MAAAA,WAAW,CAACC,OAAZ,CAAoBH,KAApB;AACAE,MAAAA,WAAW,CAACC,OAAZ,GAAsB,IAAtB;AACD;AACD;AACN;AACA;AACA;AACA;AACA;;AACK,GAXQ,EAWN,CAACD,WAAW,CAACC,OAAb,EAAsBH,KAAtB,CAXM,CAAT;AAaA,QAAMI,cAAc,GAAGR,WAAW,CAAES,WAAD,IAAiB;AAClDJ,IAAAA,QAAQ,CAACI,WAAD,CAAR;AACA,WAAO,IAAIC,OAAJ,CAAYC,OAAO,IAAI;AAC5BL,MAAAA,WAAW,CAACC,OAAZ,GAAsBI,OAAtB;AACD,KAFM,CAAP;AAGD,GALiC,EAK/B,CAACN,QAAD,CAL+B,CAAlC;AAOA,SAAO,CAACD,KAAD,EAAQI,cAAR,CAAP;AACD,CAzBI","sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from 'react';\r\n\r\nexport const useStateWithPromise = (initialState) => {\r\n    const [state, setState] = useState(initialState);\r\n    const resolverRef = useRef(null);\r\n  \r\n    useEffect(() => {\r\n      if (resolverRef.current) {\r\n        resolverRef.current(state);\r\n        resolverRef.current = null;\r\n      }\r\n      /**\r\n       * Since a state update could be triggered with the exact same state again,\r\n       * it's not enough to specify state as the only dependency of this useEffect.\r\n       * That's why resolverRef.current is also a dependency, because it will guarantee,\r\n       * that handleSetState was called in previous render\r\n       */\r\n    }, [resolverRef.current, state]);\r\n  \r\n    const handleSetState = useCallback((stateAction) => {\r\n      setState(stateAction);\r\n      return new Promise(resolve => {\r\n        resolverRef.current = resolve;\r\n      });\r\n    }, [setState])\r\n  \r\n    return [state, handleSetState];\r\n  };"]},"metadata":{},"sourceType":"module"}