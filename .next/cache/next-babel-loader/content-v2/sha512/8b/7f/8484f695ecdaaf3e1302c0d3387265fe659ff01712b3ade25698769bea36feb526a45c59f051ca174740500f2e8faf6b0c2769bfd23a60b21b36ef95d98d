{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport firebase from './firebase.js';\nimport { db } from './firebase';\nimport getStripe from './stripe.js';\nconst firestore = firebase.firestore();\nexport const getAllProjects = async () => {\n  const snapshot = await firestore.collection('projects').get();\n  const projects = [];\n  snapshot.forEach(doc => {\n    projects.push(_objectSpread({\n      id: doc.id\n    }, doc.data()));\n  });\n  console.log(projects);\n  return {\n    projects\n  };\n}; // CLIENT-DATA\n\nexport const createUser = (uid, data) => {\n  return firestore.collection('users').doc(uid).set(_objectSpread({\n    uid\n  }, data), {\n    merge: true\n  }); // merge powoduje, że każde id będzie unikatowe\n};\nexport const getUser = async uid => {\n  const user = await firestore.collection('users').get();\n  const users = [];\n  user.forEach(doc => {\n    users.push(_objectSpread({\n      id: doc.id\n    }, doc.data()));\n  });\n  return {\n    users\n  };\n}; // STARTUP-DATA\n\nexport const createStartupData = data => {\n  // Wszystkie informacje wrzucamy, a potem będziemy je pobierali dla odpowiedniego użytkownika\n  return firestore.collection('startup-data').add(data);\n}; // PROJECT DELETE\n\nexport const deleteProject = async projectId => {\n  // ONE PARTICULAR PROJECT\n  const snapshot = await firestore.collection('projects').where('projectId', '==', projectId).get();\n  const batch = firestore.batch();\n  console.log(batch);\n  snapshot.forEach(doc => {\n    batch.delete(doc.ref);\n  });\n  return batch.commit();\n}; // STRIPE\n\nexport const createCheckoutSession = async uid => {\n  const checkoutSessionRef = await db.collection('users').doc(uid) // TO JEST DO ZMIANY Z PODSTAWOWEJ TEMPLATKI\n  .collection('checkout_sessions').add({\n    price: 'price_1IVJjNBdXPtKajNHvs4FpbR7',\n    // TO JEST DO ZMIANY Z PODSTAWOWEJ TEMPLATKI\n    success_url: `${window.location.origin}/dashboard/account`,\n    cancel_url: `${window.location.origin}/dashboard/account`\n  }); // Wait for the CheckoutSession to get attached by the extension\n\n  checkoutSessionRef.onSnapshot(async snap => {\n    // TO JEST DO ZMIANY Z PODSTAWOWEJ TEMPLATKI (tutaj dodajemy tylko słówko async)\n    const {\n      error,\n      sessionId\n    } = snap.data();\n\n    if (error) {\n      // Show an error to your customer and\n      // inspect your Cloud Function logs in the Firebase console.\n      alert(`An error occured: ${error.message}`);\n    }\n\n    if (sessionId) {\n      // We have a session, let's redirect to Checkout\n      // Init Stripe\n      const stripe = await getStripe(); // TO JEST DO ZMIANY Z PODSTAWOWEJ TEMPLATKI (funkcja getStripe w pliku stripe.js)\n\n      stripe.redirectToCheckout({\n        sessionId\n      });\n    }\n  });\n}; // $29.99 for 10 units\n\nexport const createCheckoutSession10 = async uid => {\n  const checkoutSessionRef = await db.collection('users').doc(uid) // TO JEST DO ZMIANY Z PODSTAWOWEJ TEMPLATKI\n  .collection('checkout_sessions').add({\n    price: 'price_1IVgUmBdXPtKajNH4VVwl6dw',\n    // TO JEST DO ZMIANY Z PODSTAWOWEJ TEMPLATKI\n    success_url: `${window.location.origin}/dashboard/account`,\n    cancel_url: `${window.location.origin}/dashboard/account`\n  }); // Wait for the CheckoutSession to get attached by the extension\n\n  checkoutSessionRef.onSnapshot(async snap => {\n    // TO JEST DO ZMIANY Z PODSTAWOWEJ TEMPLATKI (tutaj dodajemy tylko słówko async)\n    const {\n      error,\n      sessionId\n    } = snap.data();\n\n    if (error) {\n      // Show an error to your customer and\n      // inspect your Cloud Function logs in the Firebase console.\n      alert(`An error occured: ${error.message}`);\n    }\n\n    if (sessionId) {\n      // We have a session, let's redirect to Checkout\n      // Init Stripe\n      const stripe = await getStripe(); // TO JEST DO ZMIANY Z PODSTAWOWEJ TEMPLATKI (funkcja getStripe w pliku stripe.js)\n\n      stripe.redirectToCheckout({\n        sessionId\n      });\n    }\n  });\n};\nexport const goToBillingPortal = async () => {\n  // Do tej funkcji musimy zaimportować firebase/functions w pliku firebase.js\n  const functionRef = firebase.app().functions('us-central1').httpsCallable('ext-firestore-stripe-subscriptions-createPortalLink');\n  const {\n    data\n  } = await functionRef({\n    returnUrl: `${window.location.origin}/dashboard/account`\n  });\n  window.location.assign(data.url);\n}; // export const getCurrentPlan = async () => {\n//   const decodedToken = await firebase.auth().currentUser.getIdTokenResult();\n//   // console.log(decodedToken.claims.stripeRole); // TO POKAZUJE AKTUALNY PLAN ZALOGOWANEGO UŻYTKOWNIKA NP. BASIC / PREMIUM\n//   return decodedToken.claims.stripeRole;\n// };","map":null,"metadata":{},"sourceType":"module"}